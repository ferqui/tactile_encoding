"""
The bio inspired optimization is based on the evolution scheme.
It goes as follows:
1. create intial population of size P
loop:
    2. validate fitness of single individual P_n
    3. select best x inidividuals and pertubate the genes (neuron parameters) 
    and include y random individuals to create population of P
    4. reached stop criterion end
"""

import numpy as np
import matplotlib.pyplot as plt
import random
import torch
import pandas as pd

from datasets import load_data
from parameters import encoding_parameter

neuron_model = 'mn_neuron' # iz_neuon, lif_neuron
generations = 20 # stop criterion
P = 10

# Mihilas-Niebur neuron
if neuron_model is 'mn_neuron':
    from parameters.encoding_parameter import mn_parameter
    from models import MN_neuron
    neuron = MN_neuron
    parameter = mn_parameter
# Izhikevich neuron
elif neuron_model is 'iz_neuron':
    from parameters.encoding_parameter import iz_parameter
    from models import IZ_neuron
    neuron = IZ_neuron
    parameter = iz_parameter
# LIF neuron
else:
    from parameters.encoding_parameter import lif_parameter
    from models import LIF_neuron
    neuron = LIF_neuron
    parameter = lif_parameter

parameters_list = ["a", "A1", "A2"]
parameter_to_optimize = []
for _, param in enumerate(parameter):
    if param[0] in parameters_list:
        parameter_to_optimize.append(param)

record = []
population_list = []
param_width = []
# create inital populataton of size P
for counter in range(P):
    individual = {}
    individual['identifier'] = counter
    # create inital parameter values
    for _, param in enumerate(parameter_to_optimize):
        param_space = np.arange(param[1], param[2], param[3]) # create parameter space to draw from
        individual[param[0]] = random.choice(param_space) # draw a random number out of parameter space
        # extract the parameter width for later
        if counter == 0:
            param_width.append(np.diff((param[1], param[2]))) # define parameter width (min - max)
    population_list.append(individual)

# load data
data_dict = pd.read_pickle(
            "./data/data_braille_letters_0.0.pkl")  # 100Hz data (new resampled dataset)
data_neuron, labels, timestamps, le, data = load_data("./data/data_braille_letters_0.0.pkl", upsample_fac=1.0, norm_val=1, filtering=False)
# iterate for 'generataions' cicles
for generation in range(generations):
    highest_fitness = 0
    best_individual = None
    # validate fitness for each individual
    for identifier, individual in enumerate(population_list):
        # create neuron response for individual
        neurons = MN_neuron(24, individual, dt=1/100, train=False)

        input = data_neuron
        output_s = [] # monitor only spikes for now
        # output_v = []
        # output_I1 = []
        # output_I2 = []
        # output_thr = []

        for t in range(input.shape[0]):
            out = neurons(input[t])
            output_s.append(out.cpu().numpy())
            # output_v.append(neurons.state.V.cpu().numpy())
            # output_I1.append(neurons.state.i1.cpu().numpy())
            # output_I2.append(neurons.state.i2.cpu().numpy())
            # output_thr.append(neurons.state.Thr.cpu().numpy())
        output_s = np.stack(output_s)
        # output_v = np.stack(output_v)
        # output_I1 = np.stack(output_I1)
        # output_I2 = np.stack(output_I2)
        # output_thr = np.stack(output_thr)

        # TODO validate fitness (for now TOYexample: the more spikes the better)
        fitness = np.sum(output_s) # change to something meaningful
        individual['fitness'] = fitness
        if fitness > highest_fitness:
            highest_fitness = np.sum(output_s)
            best_individual = identifier
    
    # safe outcome for the record
    record.append(population_list)
    
    # create next generation
    for identifier, individual in enumerate(population_list):
        if identifier <= 0.75*len(population_list):
            # create first 75% from best (TODO inlcude more vaiance like top 10%)
            for counter, param in enumerate(parameter_to_optimize):
                # print(param[1], param[2])
                # print(population_list[best_individual][param[0]])
                # print(np.random.normal(population_list[best_individual][param[0]], param_width[counter]*0.1, 1))
                new_val = np.random.normal(population_list[best_individual][param[0]], param_width[counter]*0.1, 1)
                individual[param[0]] =  new_val[0] # (mu, sigma, nb_samples)
        else:
            # create remaning 25% random
            for _, param in enumerate(parameter_to_optimize):
                param_space = np.arange(param[1], param[2], param[3]) # create parameter space to draw from
                individual[param[0]] = random.choice(param_space) # draw a random number out of parameter space
    print("Generation {} of {} finished".format(generation, generations))
print("End of the evolution reached")
